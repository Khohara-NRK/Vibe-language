ðŸ“œ Vibe Language Specification (v1.0.0)1. IntroductionVibe is a high-level, Intent-Oriented Programming (IOP) language. It represents a paradigm shift where the primary unit of computation is "Intent" rather than "Instruction."Traditional compilers focus on syntax validation; the Vibe Engine focuses on semantic mapping. It bridges the gap between human natural language and machine-executable code through an Agentic Layer.2. Program StructureA Vibe program (.vibe) consists of three primary segments:The Manifest (Goal/Platform): Defines the scope and target environment.The Logic Layer (!): Deterministic, strict execution rules.The Creative Layer (~): Nondeterministic, agent-guided styling and UX.The Action Layer (>): Tool-calling and imperative commands.3. Lexical Grammar3.1 OperatorsVibe uses three "Force Operators" to dictate how the Agentic Runtime handles a line:OperatorNamePurpose!The ForceExplicit logic. Compiles to hard-coded structures (C++, Rust).~The VibeHeuristic logic. The Agent interprets this based on "Vibes" (Styles).>The ActionEvent triggers or Tool calls (e.g., > Print, > Send Email).3.2 Symbols#: Single-line comments.:: Defines the start of a block or assigns a value.${var}: Variable interpolation within strings.4. Data & VariablesVibe is dynamically typed and contextually inferred.Assignment: ! Set [Variable] to [Value] or [Variable] is [Value]Types: Vibe understands Strings, Numbers, Lists, and "Vibe-Objects" (UI components).Code snippet! Set Score to 100
! Tasks is ["Code", "Vibe", "Repeat"]
5. Iterative Intent (Repetition)Vibe replaces traditional loops with Natural Iteration.5.1 The Repeat PatternUsed for a fixed number of executions.Code snippetRepeat [Integer] times:
    > [Action]
5.2 The Collection PatternUsed for processing lists or datasets.Code snippetEvery [Item] in [Collection]:
    ~ Style this [Item] as a card.
    ! Add 1 to Counter.
5.3 The Persistent PatternUsed for listeners and background processes.Code snippetAlways:
    If [Condition]:
        > Trigger Action.
6. UI & The "Canvas" SystemVibe treats UI as a descriptive declaration. The Vibe-Canvas engine maps these to native components (HTML/SwiftUI/XML).Screens: Defined by Screen [Name]:Styling: Controlled by the ~ operator.Events: Defined by On [Trigger]:7. Memory Management (Agentic GC)Unlike Câ€™s manual management or Javaâ€™s Garbage Collection, Vibe uses Intent-Based Garbage Collection (IBGC).Memory is allocated per Goal.When a Goal or Flow is marked as completed by the Agent, the entire memory heap for that context is purged.Deterministic objects (!) are stored in a stack-based memory for speed.Creative objects (~) are stored in a heap-based context for flexibility.8. Compiler & Runtime ArchitectureThe Vibe lifecycle consists of four stages:Semantic Analysis: The Agent parses natural language into an Intent-Tree.Cross-Platform Mapping: The Tree is mapped to target languages (e.g., > becomes a function call in JS).Creative Synthesis: ~ lines are sent to a design-specific model to generate CSS/Layouts.Vibe Lock: The vibe lock command freezes the generated code into a production-ready binary.9. Error Handling (The "Vibe Check")Vibe does not "crash" with cryptic errors. If the engine finds an ambiguity, it performs a Vibe Check.Ambiguity: "I don't know what color 'Cyber-Sunset' is."Resolution: The Agent proposes 3 Hex codes. The user selects one, and the compiler continues.
